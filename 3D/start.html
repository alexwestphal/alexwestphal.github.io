<html>
<head>
    <title>Start</title>
    <style>
        body { margin: 0; padding: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>
<body>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
<script>

    var VIEW_ANGLE = 45, NEAR = 0.1, FAR = 10000;
    var scene, camera, renderer, controls;

    var chessboard = function() {
        var SIZE = 20, WIDTH = 8, LENGTH = 8;

        var white = new THREE.MeshLambertMaterial({color: 0xFFFFFF});
        var black = new THREE.MeshLambertMaterial({color: 0x666666});

        var geometry = new THREE.Geometry();

        for(var z=0 ; z<=LENGTH ; z++) for(var x=0; x<=WIDTH; x++) {
            geometry.vertices.push(new THREE.Vector3( x*SIZE, 0,  z*SIZE ));
        }
        for(var z=0 ; z<LENGTH ; z++) for(var x=0; x<WIDTH; x+=2) {
            var e =  0 == z % 2 ? 0 : 1;
            var a = z * (WIDTH + 1) + e,
                b = (z + 1) * (WIDTH + 1) + e;

            geometry.faces.push(
                    new THREE.Face3( a+x, b+x,   b+x+1 ),
                    new THREE.Face3( a+x, b+x+1, a+x+1 )
            );
        }

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();
        geometry.computeBoundingSphere();

        return new THREE.Mesh(geometry, white);
    };

    var init = function() {
        scene = new THREE.Scene();
        var WIDTH = window.innerWidth,
            HEIGHT = window.innerHeight;

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(WIDTH, HEIGHT);
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(VIEW_ANGLE, WIDTH / HEIGHT, NEAR, FAR);
        scene.add(camera);
        camera.position.z = 300;
        camera.position.y = 20;

        window.addEventListener('resize', function() {
            var WIDTH = window.innerWidth,
                HEIGHT = window.innerHeight;
            renderer.setSize(WIDTH, HEIGHT);
            camera.aspect = WIDTH / HEIGHT;
            camera.updateProjectionMatrix();
        });

        var light = new THREE.HemisphereLight(0x888888, 0xB4B4B4, 1);
        scene.add(light);

        var redMaterial = new THREE.MeshLambertMaterial({color: 0xDD4444, side: THREE.DoubleSide, wireframe: false});
        var blueMaterial = new THREE.MeshLambertMaterial({color: 0x2222DD, side: THREE.DoubleSide, wireframe: false});

        var path = new THREE.Path([new THREE.Vector2(-100, -10)]);
        path.lineTo(-40,-10);
        path.bezierCurveTo(-10,-10, -10,-30, 20,-30);
        path.bezierCurveTo(50,-30, 50,30, 20,30);
        path.bezierCurveTo(-10,30, -10,10, -40,10);
        path.lineTo(-70, 10);

        var points = path.getPoints();
        for(var i=0; i<points.length; i++) {
            points[i] = new THREE.Vector3(points[i].x, points[i].y, 0);
        }
        for(i=1; i<points.length-1; i++) points[i].z = 10*Math.sin(3*i*Math.PI/(points.length-2));

        console.log(points);

        var redRope = new THREE.Mesh(new THREE.TubeGeometry(new THREE.SplineCurve3(points), 64, 4), redMaterial);
        var blueRope = new THREE.Mesh(new THREE.TubeGeometry(new THREE.SplineCurve3(points), 64, 4), blueMaterial);

        blueRope.rotateOnAxis(new THREE.Vector3(0,1,0), Math.PI);
        scene.add(redRope);
        scene.add(blueRope);

        var floor = chessboard();
        floor.translateX(-80);
        floor.translateY(-50);
        floor.translateZ(-80);
        scene.add(floor);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        //controls.autoRotate = true;
    };


    var render = function() {
        requestAnimationFrame(render);

        renderer.render(scene, camera);
        controls.update();
   };

    init();
    render();

</script>
</body>
</html>